API REFERENCE
SERVER APIS
renderToString
Pitfall
renderToString does not support streaming or waiting for data. See the alternatives.

renderToString renders a React tree to an HTML string.

const html = renderToString(reactNode)
Reference
renderToString(reactNode)
Usage
Rendering a React tree as HTML to a string
Alternatives
Migrating from renderToString to a streaming method on the server
Removing renderToString from the client code
Troubleshooting
When a component suspends, the HTML always contains a fallback
Reference 
renderToString(reactNode) 
On the server, call renderToString to render your app to HTML.

import { renderToString } from 'react-dom/server';

const html = renderToString(<App />);
On the client, call hydrateRoot to make the server-generated HTML interactive.

See more examples below.

Parameters 
reactNode: A React node you want to render to HTML. For example, a JSX node like <App />.

optional options: An object for server render.

optional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot.
Returns 
An HTML string.

Caveats 
renderToString has limited Suspense support. If a component suspends, renderToString immediately sends its fallback as HTML.

renderToString works in the browser, but using it in the client code is not recommended.

Usage 
Rendering a React tree as HTML to a string 
Call renderToString to render your app to an HTML string which you can send with your server response:

import { renderToString } from 'react-dom/server';

// The route handler syntax depends on your backend framework
app.use('/', (request, response) => {
  const html = renderToString(<App />);
  response.send(html);
});
This will produce the initial non-interactive HTML output of your React components. On the client, you will need to call hydrateRoot to hydrate that server-generated HTML and make it interactive.

Pitfall
renderToString does not support streaming or waiting for data. See the alternatives.

Alternatives 
Migrating from renderToString to a streaming method on the server 
renderToString returns a string immediately, so it does not support streaming or waiting for data.

When possible, we recommend using these fully-featured alternatives:

If you use Node.js, use renderToPipeableStream.
If you use Deno or a modern edge runtime with Web Streams, use renderToReadableStream.
You can continue using renderToString if your server environment does not support streams.

Removing renderToString from the client code 
Sometimes, renderToString is used on the client to convert some component to HTML.

// ðŸš© Unnecessary: using renderToString on the client
import { renderToString } from 'react-dom/server';

const html = renderToString(<MyIcon />);
console.log(html); // For example, "<svg>...</svg>"
Importing react-dom/server on the client unnecessarily increases your bundle size and should be avoided. If you need to render some component to HTML in the browser, use createRoot and read HTML from the DOM:

import { createRoot } from 'react-dom/client';
import { flushSync } from 'react-dom';

const div = document.createElement('div');
const root = createRoot(div);
flushSync(() => {
  root.render(<MyIcon />);
});
console.log(div.innerHTML); // For example, "<svg>...</svg>"
The flushSync call is necessary so that the DOM is updated before reading its innerHTML property.

Troubleshooting 
When a component suspends, the HTML always contains a fallback 
renderToString does not fully support Suspense.

If some component suspends (for example, because itâ€™s defined with lazy or fetches data), renderToString will not wait for its content to resolve. Instead, renderToString will find the closest <Suspense> boundary above it and render its fallback prop in the HTML. The content will not appear until the client code loads.

To solve this, use one of the recommended streaming solutions. They can stream content in chunks as it resolves on the server so that the user sees the page being progressively filled in before the client code loads.